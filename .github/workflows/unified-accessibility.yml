name: 'Unified Accessibility Scanner'

on:
  schedule:
    # Run every Monday at 9:00 AM UTC (weekly)
    - cron: '0 9 * * 1'
  workflow_dispatch:
    inputs:
      target_url:
        description: 'URL to scan (leave empty for default)'
        required: false
        type: string
      standards:
        description: 'Accessibility standards to test'
        required: false
        default: 'WCAG2AA'
        type: choice
        options:
          - 'WCAG2A'
          - 'WCAG2AA'
          - 'WCAG2AAA'
          - 'Section508'
          - 'EN301549'
      environment:
        description: 'Environment to test'
        required: false
        default: 'production'
        type: choice
        options:
          - 'development'
          - 'staging'
          - 'production'
      fail_on_issues:
        description: 'Fail workflow if accessibility issues found'
        required: false
        default: false
        type: boolean
  pull_request:
    branches: [main, develop]
    types: [opened, synchronize, reopened]
  push:
    branches: [main]

env:
  ACCESSIBILITY_CONFIG_PATH: '.github/accessibility-config.yml'
  DEFAULT_TARGET_URL: 'https://ncaa-d1-softball.netlify.app/'
  NODE_VERSION: '20'
  REPORT_DIR: 'accessibility-reports'

jobs:
  # Job 1: Setup and Configuration
  setup:
    name: 'Setup and Configuration'
    runs-on: ubuntu-latest
    outputs:
      target-url: ${{ steps.config.outputs.target-url }}
      standards: ${{ steps.config.outputs.standards }}
      environment: ${{ steps.config.outputs.environment }}
      fail-on-issues: ${{ steps.config.outputs.fail-on-issues }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Parse configuration and inputs
        id: config
        run: |
          echo "Parsing accessibility configuration..."
          
          # Set values from inputs or defaults
          TARGET_URL="${{ github.event.inputs.target_url || env.DEFAULT_TARGET_URL }}"
          STANDARDS="${{ github.event.inputs.standards || 'WCAG2AA' }}"
          ENVIRONMENT="${{ github.event.inputs.environment || 'production' }}"
          FAIL_ON_ISSUES="${{ github.event.inputs.fail_on_issues || 'false' }}"
          
          # Override with environment-specific settings if config exists
          if [ -f "$ACCESSIBILITY_CONFIG_PATH" ]; then
            echo "Loading configuration from $ACCESSIBILITY_CONFIG_PATH"
            
            # Install yq if not available
            if ! command -v yq &> /dev/null; then
              sudo snap install yq --classic || echo "yq installation failed, using defaults"
            fi
            
            # Override target URL based on environment
            if command -v yq &> /dev/null; then
              if [ "$ENVIRONMENT" = "development" ]; then
                TARGET_URL=$(yq eval '.environments.development.target_url // env(TARGET_URL)' $ACCESSIBILITY_CONFIG_PATH)
              elif [ "$ENVIRONMENT" = "staging" ]; then
                TARGET_URL=$(yq eval '.environments.staging.target_url // env(TARGET_URL)' $ACCESSIBILITY_CONFIG_PATH)
              elif [ "$ENVIRONMENT" = "production" ]; then
                TARGET_URL=$(yq eval '.environments.production.target_url // env(TARGET_URL)' $ACCESSIBILITY_CONFIG_PATH)
              fi
            fi
          fi
          
          echo "=== Configuration Summary ==="
          echo "Target URL: $TARGET_URL"
          echo "Standards: $STANDARDS"
          echo "Environment: $ENVIRONMENT"
          echo "Fail on Issues: $FAIL_ON_ISSUES"
          
          # Set outputs
          echo "target-url=$TARGET_URL" >> $GITHUB_OUTPUT
          echo "standards=$STANDARDS" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "fail-on-issues=$FAIL_ON_ISSUES" >> $GITHUB_OUTPUT

  # Job 2: Comprehensive Accessibility Scanning
  accessibility-scan:
    name: 'Comprehensive Accessibility Scan'
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Create reports directory
        run: mkdir -p ${{ env.REPORT_DIR }}

      - name: Install accessibility testing tools
        run: |
          echo "Installing global accessibility tools..."
          npm install -g pa11y @axe-core/cli lighthouse
          
          echo "Installing Playwright dependencies..."
          npm install @axe-core/playwright --save-dev --no-save
          
          echo "Verifying Playwright installation..."
          if npm list @axe-core/playwright >/dev/null 2>&1; then
            echo "✅ @axe-core/playwright installed successfully"
          else
            echo "❌ @axe-core/playwright installation failed"
          fi
          
      - name: Install Playwright browsers
        run: |
          npx playwright install chromium --with-deps || echo "Browser installation failed, continuing with other tools"

      - name: Create pa11y configuration file
        run: |
          cat > pa11y.json << 'EOF'
          {
            "chromeLaunchConfig": {
              "args": [
                "--no-sandbox",
                "--disable-dev-shm-usage",
                "--disable-gpu",
                "--headless"
              ]
            },
            "timeout": 30000,
            "wait": 3000,
            "standard": "WCAG2AA",
            "runners": ["htmlcs"],
            "ignore": []
          }
          EOF

      - name: Run Axe-core accessibility scan
        run: |
          echo "Running Axe-core scan..."
          TARGET_URL="${{ needs.setup.outputs.target-url }}"
          
          # Run axe scan with custom configuration
          npx @axe-core/cli --stdout --save ${{ env.REPORT_DIR }}/axe-report.json "$TARGET_URL" || echo "Axe scan completed with issues"
          
          # Create metrics file
          if [ -f "${{ env.REPORT_DIR }}/axe-report.json" ]; then
            echo "Processing axe results..."
            node -e "
              const fs = require('fs');
              const data = JSON.parse(fs.readFileSync('${{ env.REPORT_DIR }}/axe-report.json', 'utf8'));
              const violations = data.violations || [];
              const metrics = {
                total: violations.length,
                byImpact: violations.reduce((acc, v) => { acc[v.impact] = (acc[v.impact] || 0) + 1; return acc; }, {}),
                colorContrastFailures: violations.filter(v => v.id === 'color-contrast').length,
                passes: (data.passes || []).length,
                incomplete: (data.incomplete || []).length,
              };
              fs.writeFileSync('${{ env.REPORT_DIR }}/axe-metrics.json', JSON.stringify(metrics, null, 2));
              console.log('Axe metrics created');
            " || echo "Axe metrics creation failed"
          fi

      - name: Run Pa11y accessibility scan
        run: |
          echo "Running Pa11y scan..."
          TARGET_URL="${{ needs.setup.outputs.target-url }}"
          
          # Run pa11y with multiple reporters
          pa11y --config pa11y.json --reporter json --reporter html --reporter csv "$TARGET_URL" \
            > ${{ env.REPORT_DIR }}/pa11y-report.json \
            2> ${{ env.REPORT_DIR }}/pa11y-report.html || echo "Pa11y scan completed with issues"
          
          # Ensure valid JSON even if pa11y fails
          if [ ! -f "${{ env.REPORT_DIR }}/pa11y-report.json" ] || [ ! -s "${{ env.REPORT_DIR }}/pa11y-report.json" ]; then
            echo "[]" > ${{ env.REPORT_DIR }}/pa11y-report.json
          fi

      - name: Run Lighthouse accessibility audit
        run: |
          echo "Running Lighthouse accessibility audit..."
          TARGET_URL="${{ needs.setup.outputs.target-url }}"
          
          # Run lighthouse for desktop with proper emulation settings
          lighthouse "$TARGET_URL" \
            --only-categories=accessibility \
            --output=json \
            --output-path=${{ env.REPORT_DIR }}/lighthouse-accessibility-desktop.json \
            --chrome-flags="--headless --no-sandbox --disable-dev-shm-usage" \
            --form-factor=desktop \
            --screenEmulation.disabled=true \
            --screenEmulation.mobile=false || echo "Lighthouse desktop scan completed with issues"
          
          # Run lighthouse for mobile with explicit mobile emulation
          lighthouse "$TARGET_URL" \
            --only-categories=accessibility \
            --output=json \
            --output-path=${{ env.REPORT_DIR }}/lighthouse-accessibility-mobile.json \
            --chrome-flags="--headless --no-sandbox --disable-dev-shm-usage" \
            --form-factor=mobile \
            --screenEmulation.mobile=true || echo "Lighthouse mobile scan completed with issues"

      - name: Run Playwright accessibility tests
        run: |
          echo "Running Playwright accessibility tests..."
          
          # Create Playwright output directories for artifacts (traces, screenshots, etc.)
          mkdir -p ${{ env.REPORT_DIR }}/playwright-results
          
          # Run Playwright tests.
          # --reporter=json on CLI typically outputs to 'playwright-report/results.json' by default.
          # Removing --reporter=json from CLI to ensure playwright.config.js reporter settings are used.
          TARGET_URL="${{ needs.setup.outputs.target-url }}" npx playwright test tests/accessibility/accessibility.spec.js \\
            --project=chromium \\
            --output-dir=${{ env.REPORT_DIR }}/playwright-results || echo "Playwright tests completed with issues"
          
          # Define source and target for the report
          # The playwright.config.js specifies 'playwright-report/results.json' as the output for the JSON reporter.
          PLAYWRIGHT_JSON_REPORT_SOURCE="playwright-report/results.json"
          PLAYWRIGHT_JSON_REPORT_TARGET="${{ env.REPORT_DIR }}/playwright-report.json"

          # Ensure the target directory for the report exists (it should, as REPORT_DIR is created earlier)
          mkdir -p "$(dirname "$PLAYWRIGHT_JSON_REPORT_TARGET")"

          # Move the JSON report from the default location to the consolidated report directory
          if [ -f "$PLAYWRIGHT_JSON_REPORT_SOURCE" ]; then
            mv "$PLAYWRIGHT_JSON_REPORT_SOURCE" "$PLAYWRIGHT_JSON_REPORT_TARGET"
            echo "Moved Playwright report from $PLAYWRIGHT_JSON_REPORT_SOURCE to $PLAYWRIGHT_JSON_REPORT_TARGET"
          # Fallback to the old locations, just in case, with a warning.
          elif [ -f "test-results/results.json" ]; then
            echo "Warning: Playwright report found at 'test-results/results.json' (expected '$PLAYWRIGHT_JSON_REPORT_SOURCE'). Moving it."
            mv "test-results/results.json" "$PLAYWRIGHT_JSON_REPORT_TARGET"
          elif [ -f "results.json" ]; then
            echo "Warning: Playwright report found at 'results.json' (expected '$PLAYWRIGHT_JSON_REPORT_SOURCE'). Moving it."
            mv "results.json" "$PLAYWRIGHT_JSON_REPORT_TARGET"
          else
            echo "Playwright JSON report not found at '$PLAYWRIGHT_JSON_REPORT_SOURCE' or common fallbacks. Creating an empty report at '$PLAYWRIGHT_JSON_REPORT_TARGET'."
            echo "[]" > "$PLAYWRIGHT_JSON_REPORT_TARGET"
          fi

      - name: Create enhanced keyboard navigation test
        run: |
          echo "Creating enhanced keyboard navigation test..."
          cat > enhanced-keyboard-test.mjs << 'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import path from 'path';
          import { fileURLToPath } from 'url';

          const __filename = fileURLToPath(import.meta.url);
          const __dirname = path.dirname(__filename);

          async function testKeyboardNavigation() {
            const browser = await chromium.launch({ headless: true });
            const page = await browser.newPage();
            const issues = [];
            
            try {
              const targetUrl = process.env.TARGET_URL || 'https://ncaa-d1-softball.netlify.app/';
              console.log(`Testing keyboard navigation on: ${targetUrl}`);
              await page.goto(targetUrl, { waitUntil: 'networkidle', timeout: 30000 });
              
              // Test focusable elements
              const focusableElements = await page.$$eval('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])', elements => {
                return elements.map(el => ({
                  tagName: el.tagName,
                  id: el.id,
                  className: el.className,
                  tabIndex: el.tabIndex,
                  textContent: el.textContent ? el.textContent.trim().substring(0, 50) : '',
                  isVisible: el.offsetParent !== null
                }));
              });
              
              console.log(`Found ${focusableElements.length} focusable elements`);
              
              if (focusableElements.length === 0) {
                issues.push({
                  type: 'keyboard-navigation',
                  severity: 'critical',
                  message: 'No focusable elements found - keyboard users cannot interact with the page',
                  element: null
                });
              }
              
              // Test focus indicators
              const visibleElements = focusableElements.filter(el => el.isVisible);
              const elementsToTest = Math.min(visibleElements.length, 15);
              
              for (let i = 0; i < elementsToTest; i++) {
                await page.keyboard.press('Tab');
                
                const activeElement = await page.evaluate(() => {
                  const el = document.activeElement;
                  if (!el || el === document.body) return null;
                  
                  const computedStyle = window.getComputedStyle(el);
                  const focusStyle = window.getComputedStyle(el, ':focus');
                  
                  const hasOutline = (computedStyle.outline !== 'none' && computedStyle.outlineWidth !== '0px') ||
                                   (focusStyle.outline !== 'none' && focusStyle.outlineWidth !== '0px');
                  const hasBoxShadow = computedStyle.boxShadow !== 'none' || focusStyle.boxShadow !== 'none';
                  const hasBorder = computedStyle.borderWidth !== '0px' || focusStyle.borderWidth !== '0px';
                  
                  return {
                    tagName: el.tagName,
                    id: el.id,
                    className: el.className,
                    textContent: el.textContent ? el.textContent.trim().substring(0, 30) : '',
                    hasVisibleFocus: hasOutline || hasBoxShadow || hasBorder
                  };
                });
                
                if (activeElement && !activeElement.hasVisibleFocus) {
                  issues.push({
                    type: 'keyboard-navigation',
                    severity: 'moderate',
                    message: `Element ${activeElement.tagName} lacks visible focus indicator`,
                    element: activeElement
                  });
                }
              }
              
              // Test skip links
              const skipLinks = await page.$$eval('a[href^="#"]', links => {
                return links.filter(link => {
                  const text = link.textContent.toLowerCase();
                  return text.includes('skip') || text.includes('main');
                }).length;
              });
              
              if (skipLinks === 0) {
                issues.push({
                  type: 'keyboard-navigation',
                  severity: 'serious',
                  message: 'No skip links found - keyboard users cannot bypass navigation',
                  element: null
                });
              }
              
            } catch (error) {
              console.error('Keyboard navigation test error:', error);
              issues.push({
                type: 'keyboard-navigation',
                severity: 'critical',
                message: `Test failed: ${error.message}`,
                element: null
              });
            }
            
            await browser.close();
            
            // Ensure directory exists
            const reportDir = process.env.REPORT_DIR || 'accessibility-reports';
            if (!fs.existsSync(reportDir)) {
              fs.mkdirSync(reportDir, { recursive: true });
            }
            
            fs.writeFileSync(path.join(reportDir, 'keyboard-navigation.json'), JSON.stringify(issues, null, 2));
            console.log(`Keyboard navigation test completed. Found ${issues.length} issues.`);
            return issues.length;
          }

          testKeyboardNavigation().catch(err => {
            console.error('Test error:', err);
            process.exit(1);
          });
          EOF
          
          # Run the enhanced test with ES modules
          TARGET_URL="${{ needs.setup.outputs.target-url }}" REPORT_DIR="${{ env.REPORT_DIR }}" node enhanced-keyboard-test.mjs || echo "Enhanced keyboard test completed with issues"

      - name: Create enhanced screen reader test
        run: |
          echo "Creating enhanced screen reader test..."
          cat > enhanced-screenreader-test.mjs << 'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import path from 'path';
          import { fileURLToPath } from 'url';

          const __filename = fileURLToPath(import.meta.url);
          const __dirname = path.dirname(__filename);

          async function testScreenReaderCompatibility() {
            const browser = await chromium.launch({ headless: true });
            const page = await browser.newPage();
            const issues = [];
            
            try {
              const targetUrl = process.env.TARGET_URL || 'https://ncaa-d1-softball.netlify.app/';
              console.log(`Testing screen reader compatibility on: ${targetUrl}`);
              await page.goto(targetUrl, { waitUntil: 'networkidle', timeout: 30000 });
              
              // Test page structure
              const pageStructure = await page.evaluate(() => {
                const hasMain = document.querySelector('main, [role="main"]') !== null;
                const hasH1 = document.querySelector('h1') !== null;
                const hasLang = document.documentElement.hasAttribute('lang');
                const hasTitle = document.title && document.title.trim() !== '';
                const imagesWithoutAlt = document.querySelectorAll('img:not([alt])').length;
                const headings = Array.from(document.querySelectorAll('h1, h2, h3, h4, h5, h6')).map(h => parseInt(h.tagName[1]));
                const landmarks = document.querySelectorAll('[role="main"], [role="navigation"], [role="banner"], [role="contentinfo"], main, nav, header, footer').length;
                
                return {
                  hasMain,
                  hasH1,
                  hasLang,
                  hasTitle,
                  imagesWithoutAlt,
                  headings,
                  landmarks
                };
              });
              
              // Check for critical structural issues
              if (!pageStructure.hasMain) {
                issues.push({
                  type: 'screen-reader',
                  severity: 'critical',
                  message: 'Page lacks main landmark - screen readers cannot identify main content',
                  element: { type: 'main-landmark' }
                });
              }
              
              if (!pageStructure.hasH1) {
                issues.push({
                  type: 'screen-reader',
                  severity: 'critical',
                  message: 'Page lacks h1 heading - screen readers cannot identify page topic',
                  element: { type: 'h1-heading' }
                });
              }
              
              if (!pageStructure.hasLang) {
                issues.push({
                  type: 'screen-reader',
                  severity: 'serious',
                  message: 'HTML element missing lang attribute',
                  element: { type: 'lang-attribute' }
                });
              }
              
              if (!pageStructure.hasTitle) {
                issues.push({
                  type: 'screen-reader',
                  severity: 'serious',
                  message: 'Page missing or empty title',
                  element: { type: 'page-title' }
                });
              }
              
              if (pageStructure.imagesWithoutAlt > 0) {
                issues.push({
                  type: 'screen-reader',
                  severity: 'serious',
                  message: `${pageStructure.imagesWithoutAlt} images missing alt text`,
                  count: pageStructure.imagesWithoutAlt
                });
              }
              
              if (pageStructure.landmarks === 0) {
                issues.push({
                  type: 'screen-reader',
                  severity: 'serious',
                  message: 'No ARIA landmarks found for navigation',
                  element: { type: 'landmarks' }
                });
              }
              
              // Check heading hierarchy
              if (pageStructure.headings.length > 0) {
                let previousLevel = 0;
                for (const level of pageStructure.headings) {
                  if (level > previousLevel + 1) {
                    issues.push({
                      type: 'screen-reader',
                      severity: 'moderate',
                      message: `Heading hierarchy skip detected (h${previousLevel} to h${level})`,
                      element: { type: 'heading-hierarchy' }
                    });
                    break;
                  }
                  previousLevel = level;
                }
              }
              
              // Test form labels
              const unlabeledInputs = await page.evaluate(() => {
                const inputs = Array.from(document.querySelectorAll('input, select, textarea'));
                return inputs.filter(input => {
                  const id = input.id;
                  const hasLabel = id && document.querySelector(`label[for="${id}"]`);
                  const ariaLabel = input.getAttribute('aria-label');
                  const ariaLabelledby = input.getAttribute('aria-labelledby');
                  return !hasLabel && !ariaLabel && !ariaLabelledby;
                }).length;
              });
              
              if (unlabeledInputs > 0) {
                issues.push({
                  type: 'screen-reader',
                  severity: 'serious',
                  message: `${unlabeledInputs} form inputs missing accessible labels`,
                  count: unlabeledInputs
                });
              }
              
            } catch (error) {
              console.error('Screen reader test error:', error);
              issues.push({
                type: 'screen-reader',
                severity: 'critical',
                message: `Test failed: ${error.message}`,
                element: null
              });
            }
            
            await browser.close();
            
            // Ensure directory exists
            const reportDir = process.env.REPORT_DIR || 'accessibility-reports';
            if (!fs.existsSync(reportDir)) {
              fs.mkdirSync(reportDir, { recursive: true });
            }
            
            fs.writeFileSync(path.join(reportDir, 'screen-reader.json'), JSON.stringify(issues, null, 2));
            console.log(`Screen reader test completed. Found ${issues.length} issues.`);
            return issues.length;
          }

          testScreenReaderCompatibility().catch(err => {
            console.error('Test error:', err);
            process.exit(1);
          });
          EOF
          
          # Run the enhanced test with ES modules
          TARGET_URL="${{ needs.setup.outputs.target-url }}" REPORT_DIR="${{ env.REPORT_DIR }}" node enhanced-screenreader-test.mjs || echo "Enhanced screen reader test completed with issues"

      - name: Generate comprehensive accessibility report
        run: |
          echo "Generating comprehensive accessibility report..."
          
          # Helper function to safely extract numeric values from JSON
          safe_jq_number() {
            local file="$1"
            local query="$2"
            local default="${3:-0}"
            
            if [ -f "$file" ] && [ -s "$file" ]; then
              local result=$(jq -r "$query" "$file" 2>/dev/null)
              if [[ "$result" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
                echo "$result"
              else
                echo "$default"
              fi
            else
              echo "$default"
            fi
          }
          
          # Calculate issue counts with safe extraction
          AXCORE_ISSUES=$(safe_jq_number "${{ env.REPORT_DIR }}/axe-report.json" 'if type=="array" then .[0].violations else .violations end | length' 0)
          PA11Y_ISSUES=$(safe_jq_number "${{ env.REPORT_DIR }}/pa11y-report.json" 'length' 0)
          KEYBOARD_ISSUES=$(safe_jq_number "${{ env.REPORT_DIR }}/keyboard-navigation.json" 'length' 0)
          SCREENREADER_ISSUES=$(safe_jq_number "${{ env.REPORT_DIR }}/screen-reader.json" 'length' 0)
          LIGHTHOUSE_DESKTOP_SCORE=$(safe_jq_number "${{ env.REPORT_DIR }}/lighthouse-accessibility-desktop.json" '.categories.accessibility.score * 100' 0)
          LIGHTHOUSE_MOBILE_SCORE=$(safe_jq_number "${{ env.REPORT_DIR }}/lighthouse-accessibility-mobile.json" '.categories.accessibility.score * 100' 0)
          
          # Ensure all values are valid integers
          AXCORE_ISSUES=${AXCORE_ISSUES:-0}
          PA11Y_ISSUES=${PA11Y_ISSUES:-0}
          KEYBOARD_ISSUES=${KEYBOARD_ISSUES:-0}
          SCREENREADER_ISSUES=${SCREENREADER_ISSUES:-0}
          LIGHTHOUSE_DESKTOP_SCORE=${LIGHTHOUSE_DESKTOP_SCORE:-0}
          LIGHTHOUSE_MOBILE_SCORE=${LIGHTHOUSE_MOBILE_SCORE:-0}
          
          # Calculate totals safely
          TOTAL_ISSUES=$((AXCORE_ISSUES + PA11Y_ISSUES + KEYBOARD_ISSUES + SCREENREADER_ISSUES))
          
          # Calculate average Lighthouse score safely
          if [ "$LIGHTHOUSE_DESKTOP_SCORE" != "0" ] || [ "$LIGHTHOUSE_MOBILE_SCORE" != "0" ]; then
            LIGHTHOUSE_AVERAGE=$(echo "scale=1; ($LIGHTHOUSE_DESKTOP_SCORE + $LIGHTHOUSE_MOBILE_SCORE) / 2" | bc -l 2>/dev/null || echo "0")
          else
            LIGHTHOUSE_AVERAGE="0"
          fi
          
          echo "=== Calculated Metrics ==="
          echo "Axe-core Issues: $AXCORE_ISSUES"
          echo "Pa11y Issues: $PA11Y_ISSUES"
          echo "Keyboard Issues: $KEYBOARD_ISSUES"
          echo "Screen Reader Issues: $SCREENREADER_ISSUES"
          echo "Total Issues: $TOTAL_ISSUES"
          echo "Lighthouse Desktop Score: $LIGHTHOUSE_DESKTOP_SCORE%"
          echo "Lighthouse Mobile Score: $LIGHTHOUSE_MOBILE_SCORE%"
          echo "Lighthouse Average: $LIGHTHOUSE_AVERAGE%"
          
          # Create executive summary with validated data
          cat > ${{ env.REPORT_DIR }}/executive-summary.json << EOF
          {
            "scan_metadata": {
              "target_url": "${{ needs.setup.outputs.target-url }}",
              "standards": "${{ needs.setup.outputs.standards }}",
              "environment": "${{ needs.setup.outputs.environment }}",
              "scan_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
              "workflow_run_id": "${{ github.run_id }}",
              "workflow_run_number": "${{ github.run_number }}"
            },
            "results_summary": {
              "total_issues": $TOTAL_ISSUES,
              "critical_violations": $AXCORE_ISSUES,
              "content_issues": $PA11Y_ISSUES,
              "keyboard_issues": $KEYBOARD_ISSUES,
              "screenreader_issues": $SCREENREADER_ISSUES,
              "lighthouse_scores": {
                "desktop": $LIGHTHOUSE_DESKTOP_SCORE,
                "mobile": $LIGHTHOUSE_MOBILE_SCORE,
                "average": $LIGHTHOUSE_AVERAGE
              }
            },
            "compliance_status": {
              "wcag_2_1_aa": $([ "$AXCORE_ISSUES" -eq "0" ] && echo "true" || echo "false"),
              "section_508": $([ "$AXCORE_ISSUES" -eq "0" ] && echo "true" || echo "false"),
              "ada_compliant": $([ "$TOTAL_ISSUES" -eq "0" ] && echo "true" || echo "false"),
              "overall_status": "$([ "$TOTAL_ISSUES" -eq "0" ] && echo "passed" || echo "failed")"
            }
          }
          EOF
          
          # Create detailed HTML report
          cat > ${{ env.REPORT_DIR }}/accessibility-dashboard.html << 'EOF'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Accessibility Evaluation Dashboard</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
              .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
              .header { background: #2c3e50; color: white; padding: 20px; margin: -20px -20px 20px -20px; border-radius: 8px 8px 0 0; }
              .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin: 20px 0; }
              .metric { background: #ecf0f1; padding: 20px; border-radius: 8px; text-align: center; }
              .metric.critical { background: #e74c3c; color: white; }
              .metric.warning { background: #f39c12; color: white; }
              .metric.success { background: #27ae60; color: white; }
              .metric h3 { margin: 0 0 10px 0; font-size: 2em; }
              .metric p { margin: 0; font-size: 1.1em; }
              .section { margin: 30px 0; }
              .section h2 { border-bottom: 2px solid #3498db; padding-bottom: 10px; }
              .compliance-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; }
              .compliance-item { padding: 15px; border-radius: 8px; text-align: center; }
              .compliance-pass { background: #d5edd5; color: #2d5016; }
              .compliance-fail { background: #f8d7da; color: #721c24; }
            </style>
          </head>
          <body>
            <div class="container">
              <div class="header">
                <h1>🔍 Accessibility Evaluation Dashboard</h1>
                <p>Comprehensive accessibility audit results for NCAA D1 Softball WebApp</p>
              </div>
              
              <div class="metrics">
                <div class="metric critical">
                  <h3>{{TOTAL_ISSUES}}</h3>
                  <p>Total Issues Found</p>
                </div>
                <div class="metric {{CRITICAL_CLASS}}">
                  <h3>{{AXCORE_ISSUES}}</h3>
                  <p>WCAG Violations</p>
                </div>
                <div class="metric {{LIGHTHOUSE_CLASS}}">
                  <h3>{{LIGHTHOUSE_SCORE}}%</h3>
                  <p>Lighthouse Score</p>
                </div>
                <div class="metric {{KEYBOARD_CLASS}}">
                  <h3>{{KEYBOARD_ISSUES}}</h3>
                  <p>Keyboard Issues</p>
                </div>
              </div>
              
              <div class="section">
                <h2>📊 Compliance Status</h2>
                <div class="compliance-grid">
                  <div class="compliance-item {{WCAG_CLASS}}">
                    <h3>WCAG 2.1 AA</h3>
                    <p>{{WCAG_STATUS}}</p>
                  </div>
                  <div class="compliance-item {{ADA_CLASS}}">
                    <h3>ADA Compliance</h3>
                    <p>{{ADA_STATUS}}</p>
                  </div>
                  <div class="compliance-item {{SECTION508_CLASS}}">
                    <h3>Section 508</h3>
                    <p>{{SECTION508_STATUS}}</p>
                  </div>
                </div>
              </div>
              
              <div class="section">
                <h2>🎯 Priority Action Plan</h2>
                {{ACTION_PLAN}}
              </div>
              
              <div class="section">
                <h2>📋 Detailed Reports</h2>
                <p>Download the complete artifact for detailed technical reports including:</p>
                <ul>
                  <li><strong>axe-report.json</strong> - WCAG violations with specific elements</li>
                  <li><strong>pa11y-report.html</strong> - Visual report with screenshots</li>
                  <li><strong>lighthouse-accessibility-*.json</strong> - Performance and accessibility scores</li>
                  <li><strong>keyboard-navigation.json</strong> - Keyboard accessibility issues</li>
                  <li><strong>screen-reader.json</strong> - Screen reader compatibility issues</li>
                </ul>
              </div>
            </div>
          </body>
          </html>
          EOF
          
          # Populate the HTML template with actual values
          sed -i "s/{{TOTAL_ISSUES}}/$TOTAL_ISSUES/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{AXCORE_ISSUES}}/$AXCORE_ISSUES/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{KEYBOARD_ISSUES}}/$KEYBOARD_ISSUES/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{LIGHTHOUSE_SCORE}}/$LIGHTHOUSE_DESKTOP_SCORE/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          
          # Set CSS classes based on results
          CRITICAL_CLASS=$([ "$AXCORE_ISSUES" -eq "0" ] && echo "success" || echo "critical")
          LIGHTHOUSE_CLASS=$([ "$(echo "$LIGHTHOUSE_DESKTOP_SCORE >= 90" | bc -l 2>/dev/null || echo 0)" -eq "1" ] && echo "success" || echo "warning")
          KEYBOARD_CLASS=$([ "$KEYBOARD_ISSUES" -eq "0" ] && echo "success" || echo "warning")
          WCAG_CLASS=$([ "$AXCORE_ISSUES" -eq "0" ] && echo "compliance-pass" || echo "compliance-fail")
          ADA_CLASS=$([ "$TOTAL_ISSUES" -eq "0" ] && echo "compliance-pass" || echo "compliance-fail")
          SECTION508_CLASS=$([ "$AXCORE_ISSUES" -eq "0" ] && echo "compliance-pass" || echo "compliance-fail")
          
          sed -i "s/{{CRITICAL_CLASS}}/$CRITICAL_CLASS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{LIGHTHOUSE_CLASS}}/$LIGHTHOUSE_CLASS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{KEYBOARD_CLASS}}/$KEYBOARD_CLASS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{WCAG_CLASS}}/$WCAG_CLASS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{ADA_CLASS}}/$ADA_CLASS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{SECTION508_CLASS}}/$SECTION508_CLASS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          
          # Set status text
          WCAG_STATUS=$([ "$AXCORE_ISSUES" -eq "0" ] && echo "COMPLIANT" || echo "NON-COMPLIANT")
          ADA_STATUS=$([ "$TOTAL_ISSUES" -eq "0" ] && echo "COMPLIANT" || echo "NON-COMPLIANT")
          SECTION508_STATUS=$([ "$AXCORE_ISSUES" -eq "0" ] && echo "COMPLIANT" || echo "NON-COMPLIANT")
          
          sed -i "s/{{WCAG_STATUS}}/$WCAG_STATUS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{ADA_STATUS}}/$ADA_STATUS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          sed -i "s/{{SECTION508_STATUS}}/$SECTION508_STATUS/g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          
          # Generate action plan
          ACTION_PLAN=""
          if [ "$TOTAL_ISSUES" -eq "0" ]; then
            ACTION_PLAN="<div style='background: #d5edd5; padding: 20px; border-radius: 8px; color: #2d5016;'><h3>🎉 Congratulations!</h3><p>Your application passes all accessibility tests and is ready for users with disabilities.</p></div>"
          else
            ACTION_PLAN="<div style='background: #f8d7da; padding: 20px; border-radius: 8px; color: #721c24;'><h3>⚠️ Action Required</h3><p>$TOTAL_ISSUES accessibility issues found. Please review the detailed reports and implement the necessary fixes.</p></div>"
          fi
          
          sed -i "s|{{ACTION_PLAN}}|$ACTION_PLAN|g" ${{ env.REPORT_DIR }}/accessibility-dashboard.html
          
          echo "Accessibility dashboard generated successfully"

      - name: List generated reports
        run: |
          echo "=== Generated Accessibility Reports ==="
          ls -la ${{ env.REPORT_DIR }}/
          
          echo ""
          echo "=== File Sizes ==="
          du -h ${{ env.REPORT_DIR }}/*
          
          echo ""
          echo "=== Summary ==="
          TOTAL_ISSUES=$((
            $(jq 'if type=="array" then .[0].violations else .violations end | length' ${{ env.REPORT_DIR }}/axe-report.json 2>/dev/null || echo 0) +
            $(jq 'length' ${{ env.REPORT_DIR }}/pa11y-report.json 2>/dev/null || echo 0) +
            $(jq 'length' ${{ env.REPORT_DIR }}/keyboard-navigation.json 2>/dev/null || echo 0) +
            $(jq 'length' ${{ env.REPORT_DIR }}/screen-reader.json 2>/dev/null || echo 0)
          ))
          
          echo "Total accessibility issues found: $TOTAL_ISSUES"
          echo "Scan target: ${{ needs.setup.outputs.target-url }}"
          echo "Standards: ${{ needs.setup.outputs.standards }}"

      - name: Upload comprehensive accessibility reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: unified-accessibility-evaluation
          path: ${{ env.REPORT_DIR }}/
          retention-days: 90

      - name: Apply quality gates
        id: quality-gates
        run: |
          echo "Applying accessibility quality gates..."
          
          # Calculate issue counts
          AXCORE_TOTAL_ISSUES=$(jq 'if type=="array" then .[0].violations else .violations end | length' ${{ env.REPORT_DIR }}/axe-report.json 2>/dev/null || echo 0)
          AXCORE_CRITICAL_ISSUES=$(jq 'if type=="array" then .[0].violations else .violations end | map(select(.impact == "critical")) | length' ${{ env.REPORT_DIR }}/axe-report.json 2>/dev/null || echo 0)

          PA11Y_ISSUES=$(jq 'length' ${{ env.REPORT_DIR }}/pa11y-report.json 2>/dev/null || echo 0)

          KEYBOARD_TOTAL_ISSUES=$(jq 'length' ${{ env.REPORT_DIR }}/keyboard-navigation.json 2>/dev/null || echo 0)
          KEYBOARD_CRITICAL_ISSUES=$(jq '[.[] | select(.severity == "critical")] | length' ${{ env.REPORT_DIR }}/keyboard-navigation.json 2>/dev/null || echo 0)

          SCREENREADER_TOTAL_ISSUES=$(jq 'length' ${{ env.REPORT_DIR }}/screen-reader.json 2>/dev/null || echo 0)
          SCREENREADER_CRITICAL_ISSUES=$(jq '[.[] | select(.severity == "critical")] | length' ${{ env.REPORT_DIR }}/screen-reader.json 2>/dev/null || echo 0)
          
          LIGHTHOUSE_SCORE=$(jq '.categories.accessibility.score * 100' ${{ env.REPORT_DIR }}/lighthouse-accessibility-desktop.json 2>/dev/null || echo 0)
          
          TOTAL_ISSUES=$((AXCORE_TOTAL_ISSUES + PA11Y_ISSUES + KEYBOARD_TOTAL_ISSUES + SCREENREADER_TOTAL_ISSUES))
          TOTAL_CRITICAL_ISSUES=$((AXCORE_CRITICAL_ISSUES + KEYBOARD_CRITICAL_ISSUES + SCREENREADER_CRITICAL_ISSUES))
          
          # Default quality gate thresholds (These should ideally be loaded from accessibility-config.yml based on environment)
          # For now, using values similar to the original script or common defaults.
          # The workflow's 'setup' job should be enhanced to output these based on config.
          MAX_CRITICAL_VIOLATIONS_THRESHOLD=0 # Default, assuming strict for critical issues
          MAX_TOTAL_ISSUES_THRESHOLD=10       # Default
          MIN_LIGHTHOUSE_SCORE_THRESHOLD=85   # Default

          # TODO: Enhance 'setup' job to parse thresholds from accessibility-config.yml for the current environment
          # and use those outputs here instead of hardcoded defaults. Example:
          # MAX_CRITICAL_VIOLATIONS_THRESHOLD=${{ needs.setup.outputs.max_critical_violations_threshold }}
          
          QUALITY_GATE_PASSED=true
          FAILURES=()
          
          if [ "$TOTAL_CRITICAL_ISSUES" -gt "$MAX_CRITICAL_VIOLATIONS_THRESHOLD" ]; then
            QUALITY_GATE_PASSED=false
            FAILURES+=("Critical violations found ($TOTAL_CRITICAL_ISSUES > $MAX_CRITICAL_VIOLATIONS_THRESHOLD)")
          fi
          
          if [ "$TOTAL_ISSUES" -gt "$MAX_TOTAL_ISSUES_THRESHOLD" ]; then
            QUALITY_GATE_PASSED=false
            FAILURES+=("Total issues exceed threshold ($TOTAL_ISSUES > $MAX_TOTAL_ISSUES_THRESHOLD)")
          fi
          
          if [ "$(echo "$LIGHTHOUSE_SCORE < $MIN_LIGHTHOUSE_SCORE_THRESHOLD" | bc -l)" -eq 1 ]; then
            QUALITY_GATE_PASSED=false
            FAILURES+=("Lighthouse score is below threshold ($LIGHTHOUSE_SCORE < $MIN_LIGHTHOUSE_SCORE_THRESHOLD)")
          fi

          echo "Quality Gate Status: $QUALITY_GATE_PASSED"
          echo "Total Issues: $TOTAL_ISSUES (Threshold: $MAX_TOTAL_ISSUES_THRESHOLD)"
          echo "Critical Issues: $TOTAL_CRITICAL_ISSUES (Threshold: $MAX_CRITICAL_VIOLATIONS_THRESHOLD)"
          echo "Lighthouse Score: $LIGHTHOUSE_SCORE (Threshold: $MIN_LIGHTHOUSE_SCORE_THRESHOLD)"
          
          if [ "$FAIL_ON_ISSUES" = "true" ] && [ "$QUALITY_GATE_PASSED" = "false" ]; then
            echo "::error::Accessibility quality gates failed: ${FAILURES[*]}"
            exit 1
          else
            echo "Accessibility quality gates passed or not configured to fail workflow."
          fi
          
          echo "quality_gate_passed=$QUALITY_GATE_PASSED" >> $GITHUB_OUTPUT
          echo "total_issues=$TOTAL_ISSUES" >> $GITHUB_OUTPUT
          echo "axcore_total_issues=$AXCORE_TOTAL_ISSUES" >> $GITHUB_OUTPUT
          echo "pa11y_total_issues=$PA11Y_ISSUES" >> $GITHUB_OUTPUT
          echo "keyboard_total_issues=$KEYBOARD_TOTAL_ISSUES" >> $GITHUB_OUTPUT
          echo "screenreader_total_issues=$SCREENREADER_TOTAL_ISSUES" >> $GITHUB_OUTPUT
          
          echo "total_critical_issues=$TOTAL_CRITICAL_ISSUES" >> $GITHUB_OUTPUT
          echo "axcore_critical_issues=$AXCORE_CRITICAL_ISSUES" >> $GITHUB_OUTPUT
          echo "keyboard_critical_issues=$KEYBOARD_CRITICAL_ISSUES" >> $GITHUB_OUTPUT
          echo "screenreader_critical_issues=$SCREENREADER_CRITICAL_ISSUES" >> $GITHUB_OUTPUT
          echo "lighthouse_score=$LIGHTHOUSE_SCORE" >> $GITHUB_OUTPUT

      - name: Generate summary for GitHub Actions
        if: always()
        run: |
          echo "# 🔍 Unified Accessibility Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Target URL:** ${{ needs.setup.outputs.target-url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Standards:** ${{ needs.setup.outputs.standards }}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.setup.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Scan Date:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow Run:** ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Use outputs from the quality-gates step
          TOTAL_ISSUES="${{ steps.quality-gates.outputs.total_issues }}"
          TOTAL_CRITICAL_ISSUES="${{ steps.quality-gates.outputs.total_critical_issues }}"
          AXCORE_TOTAL_ISSUES="${{ steps.quality-gates.outputs.axcore_total_issues }}"
          AXCORE_CRITICAL_ISSUES="${{ steps.quality-gates.outputs.axcore_critical_issues }}"
          PA11Y_TOTAL_ISSUES="${{ steps.quality-gates.outputs.pa11y_total_issues }}"
          KEYBOARD_TOTAL_ISSUES="${{ steps.quality-gates.outputs.keyboard_total_issues }}"
          KEYBOARD_CRITICAL_ISSUES="${{ steps.quality-gates.outputs.keyboard_critical_issues }}"
          SCREENREADER_TOTAL_ISSUES="${{ steps.quality-gates.outputs.screenreader_total_issues }}"
          SCREENREADER_CRITICAL_ISSUES="${{ steps.quality-gates.outputs.screenreader_critical_issues }}"
          LIGHTHOUSE_SCORE="${{ steps.quality-gates.outputs.lighthouse_score }}"
          QUALITY_GATE_PASSED="${{ steps.quality-gates.outputs.quality_gate_passed }}"

          echo "## 📊 Overall Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric                        | Count | Status                                                              |"
          echo "|-------------------------------|-------|---------------------------------------------------------------------|"
          echo "| **Total Accessibility Issues**  | **$TOTAL_ISSUES** | $([ "$TOTAL_ISSUES" -eq "0" ] && echo "✅ No issues" || echo "⚠️ Issues found")   |"
          echo "| **Total Critical Issues**     | **$TOTAL_CRITICAL_ISSUES** | $([ "$TOTAL_CRITICAL_ISSUES" -eq "0" ] && echo "✅ No critical issues" || echo "🚨 CRITICAL ACTION NEEDED") |
          echo "| Lighthouse Accessibility Score| $LIGHTHOUSE_SCORE%  | $([ "$(echo "$LIGHTHOUSE_SCORE >= 90" | bc -l 2>/dev/null || echo 0)" -eq "1" ] && echo "✅ Good (90+)" || ([ "$(echo "$LIGHTHOUSE_SCORE >= 50" | bc -l 2>/dev/null || echo 0)" -eq "1" ] && echo "🟠 Needs Improvement (50-89)" || echo "🔴 Poor (<50)")) |
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "## 🔍 Detailed Results by Tool" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Tool                     | Total Issues | Critical Issues | Notes                                              |"
          echo "|--------------------------|--------------|-----------------|----------------------------------------------------|"
          echo "| Axe-core (WCAG)          | $AXCORE_TOTAL_ISSUES      | $AXCORE_CRITICAL_ISSUES      | Automated WCAG compliance checks.                  |"
          echo "| Pa11y                    | $PA11Y_TOTAL_ISSUES      | N/A             | Additional automated checks (often HTML CodeSniffer). |
          echo "| Keyboard Navigation Test | $KEYBOARD_TOTAL_ISSUES      | $KEYBOARD_CRITICAL_ISSUES      | Custom script for keyboard interaction.            |"
          echo "| Screen Reader Test       | $SCREENREADER_TOTAL_ISSUES  | $SCREENREADER_CRITICAL_ISSUES  | Custom script for screen reader compatibility.     |"
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## 🚦 Quality Gate Status" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$QUALITY_GATE_PASSED" = "true" ]; then
            echo "**Status: ✅ PASSED**" >> $GITHUB_STEP_SUMMARY
            echo "The scan met all configured quality gate thresholds." >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status: ❌ FAILED**" >> $GITHUB_STEP_SUMMARY
            echo "The scan did not meet one or more configured quality gate thresholds." >> $GITHUB_STEP_SUMMARY
            if [ "${{ needs.setup.outputs.fail-on-issues }}" = "true" ]; then
              echo "The workflow is configured to fail on quality gate violations." >> $GITHUB_STEP_SUMMARY
            else
              echo "The workflow is NOT configured to fail on quality gate violations, so it will proceed." >> $GITHUB_STEP_SUMMARY
            fi
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## 🛠️ How to Fix Issues & Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1.  **Download Artifacts:** Retrieve the \`unified-accessibility-evaluation.zip\` file from this workflow run. This artifact contains detailed JSON and HTML reports from all scanning tools." >> $GITHUB_STEP_SUMMARY
          echo "2.  **Review Reports:**" >> $GITHUB_STEP_SUMMARY
          echo "    *   Open \`accessibility-dashboard.html\` for a high-level overview and visual report (if generated)."
          echo "    *   Examine \`axe-report.json\` for specific WCAG violations, including code snippets and selectors."
          echo "    *   Check \`pa11y-report.html\` (if generated) or \`pa11y-report.json\` for additional automated findings."
          echo "    *   Inspect \`keyboard-navigation.json\` for issues related to keyboard-only access (e.g., focus order, visible focus indicators, skip links)."
          echo "    *   Analyze \`screen-reader.json\` for problems affecting screen reader users (e.g., missing landmarks (main, h1), image alt text, form labels)."
          echo "3.  **Prioritize Fixes:**" >> $GITHUB_STEP_SUMMARY
          echo "    *   Address **Critical** issues first. These are often major barriers for users."
          echo "    *   Focus on issues identified by Axe-core, as these directly relate to WCAG compliance."
          echo "    *   Ensure all interactive elements are keyboard accessible and that screen readers can correctly interpret page structure and content."
          echo "4.  **Implement Solutions:** Modify your application code (e.g., in your React components - `src/App.jsx`, `src/components/*`) to resolve the identified issues. Common fixes include:" >> $GITHUB_STEP_SUMMARY
          echo "    *   Adding a \`<main>\` element to wrap the primary content (often in `App.jsx` or a main layout component)."
          echo "    *   Ensuring a single, descriptive \`<h1>\` heading exists on each page."
          echo "    *   Providing \`alt\` text for all meaningful images."
          echo "    *   Correctly associating labels with form inputs."
          echo "    *   Ensuring visible focus indicators for all interactive elements."
          echo "5.  **Re-scan:** After applying fixes, commit your changes and re-run this workflow (e.g., by pushing to your branch or manually triggering it) to verify the issues are resolved." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "--- " >> $GITHUB_STEP_SUMMARY # Horizontal rule for separation
          echo "**Note:** This summary provides an overview. For complete details, always refer to the downloaded artifact reports." >> $GITHUB_STEP_SUMMARY

      - name: Fail workflow if quality gates failed and configured to fail
        if: needs.setup.outputs.fail-on-issues == 'true' && steps.quality-gates.outputs.passed == 'false'
        run: |
          echo "❌ Accessibility quality gates failed and fail_on_issues is enabled"
          echo "Total issues found: ${{ steps.quality-gates.outputs.total-issues }}"
          echo "Critical issues: ${{ steps.quality-gates.outputs.critical-issues }}"
          echo "Workflow will exit with failure status to enforce accessibility standards."
          exit 1

  # Job 3: PR Comment (only for pull requests)
  pr-comment:
    name: 'Update PR Comment'
    runs-on: ubuntu-latest
    needs: [setup, accessibility-scan]
    if: github.event_name == 'pull_request'
    permissions:
      pull-requests: write
    steps:
      - name: Download reports
        uses: actions/download-artifact@v4
        with:
          name: unified-accessibility-evaluation
          path: ${{ env.REPORT_DIR }}

      - name: Generate PR comment
        run: |
          # Calculate results
          AXCORE_ISSUES=$(jq 'if type=="array" then .[0].violations else .violations end | length' ${{ env.REPORT_DIR }}/axe-report.json 2>/dev/null || echo 0)
          TOTAL_ISSUES=$(jq '.results_summary.total_issues' ${{ env.REPORT_DIR }}/executive-summary.json 2>/dev/null || echo 0)
          LIGHTHOUSE_SCORE=$(jq '.results_summary.lighthouse_scores.average' ${{ env.REPORT_DIR }}/executive-summary.json 2>/dev/null || echo 0)
          
          # Create PR comment
          cat > pr-comment.md << EOF
          # 🔍 Accessibility Scan Results

          **Scan completed for:** ${{ needs.setup.outputs.target-url }}
          **Standards:** ${{ needs.setup.outputs.standards }}
          **Workflow Run:** [${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ## 📊 Results Summary

          | Metric | Value | Status |
          |--------|-------|---------|
          | **Total Issues** | $TOTAL_ISSUES | $([ "$TOTAL_ISSUES" -eq "0" ] && echo "✅ PASS" || echo "❌ FAIL") |
          | **WCAG Violations** | $AXCORE_ISSUES | $([ "$AXCORE_ISSUES" -eq "0" ] && echo "✅ PASS" || echo "❌ FAIL") |
          | **Lighthouse Score** | ${LIGHTHOUSE_SCORE}% | $([ "$(echo "$LIGHTHOUSE_SCORE >= 90" | bc -l 2>/dev/null || echo 0)" -eq "1" ] && echo "✅ GOOD" || echo "⚠️ NEEDS WORK") |

          ## 🎯 Compliance Status

          - **WCAG 2.1 AA:** $([ "$AXCORE_ISSUES" -eq "0" ] && echo "✅ COMPLIANT" || echo "❌ NON-COMPLIANT")
          - **Section 508:** $([ "$AXCORE_ISSUES" -eq "0" ] && echo "✅ COMPLIANT" || echo "❌ NON-COMPLIANT")
          - **ADA:** $([ "$TOTAL_ISSUES" -eq "0" ] && echo "✅ COMPLIANT" || echo "❌ NON-COMPLIANT")
          - **WCAG 2.0 AA:** $([ "$AXCORE_ISSUES" -eq "0" ] && echo "✅ COMPLIANT" || echo "❌ NON-COMPLIANT")

          $(if [ "$TOTAL_ISSUES" -eq "0" ]; then
            echo "## 🎉 Congratulations!"
            echo ""
            echo "Your changes pass all accessibility tests! The application is ready for users with disabilities."
          else
            echo "## ⚠️ Action Required"
            echo ""
            echo "Please address the accessibility issues found before merging. Download the detailed reports from the workflow artifacts."
            echo ""
            echo "**Priority:** Fix WCAG violations first, then address keyboard and screen reader issues."
          fi)

          ---
          📋 **Detailed Reports:** Available in workflow artifacts • 🔄 **Re-scan:** Push new commits to trigger another scan
          EOF

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('pr-comment.md', 'utf8');
            
            // Find existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes('🔍 Accessibility Scan Results')
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }